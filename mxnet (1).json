{"paragraphs":[{"text":"%pyspark\n\n\nimport time\nimport sys\nimport datetime\nimport subprocess\nimport sys\nimport os\nimport datetime\nimport traceback\nimport math\nimport random, string\nimport base64\nimport json\nfrom time import gmtime, strftime\nimport mxnet as mx\nimport numpy as np\nimport math\nimport random, string\nimport time\nfrom time import gmtime, strftime\n# forked from Apache MXNet example with minor changes for osx\nimport time\nimport mxnet as mx\nimport numpy as np\nimport cv2, os, urllib\nfrom collections import namedtuple\nBatch = namedtuple('Batch', ['data'])\n \n# Load the symbols for the networks\nwith open('/opt/demo/incubator-mxnet/synset.txt', 'r') as f:\n    synsets = [l.rstrip() for l in f]\n \n# Load the network parameters\nsym, arg_params, aux_params = mx.model.load_checkpoint('/opt/demo/incubator-mxnet/Inception-BN', 0)\n \n# Load the network into an MXNet module and bind the corresponding parameters\nmod = mx.mod.Module(symbol=sym, context=mx.cpu())\nmod.bind(for_training=False, data_shapes=[('data', (1,3,224,224))])\nmod.set_params(arg_params, aux_params)\n \n'''\nFunction to predict objects by giving the model a pointer to an image file and running a forward pass through the model.\n\ninputs:\nfilename = jpeg file of image to classify objects in\nmod = the module object representing the loaded model\nsynsets = the list of symbols representing the model\nN = Optional parameter denoting how many predictions to return (default is top 5)\n \noutputs:\npython list of top N predicted objects and corresponding probabilities\n'''\ndef predict(filename, mod, synsets, N=5):\n    tic = time.time()\n    img = cv2.cvtColor(cv2.imread(filename), cv2.COLOR_BGR2RGB)\n    if img is None:\n        return None\n    img = cv2.resize(img, (224, 224))\n    img = np.swapaxes(img, 0, 2)\n    img = np.swapaxes(img, 1, 2)\n    img = img[np.newaxis, :]\n\n    toc = time.time()\n    mod.forward(Batch([mx.nd.array(img)]))\n    prob = mod.get_outputs()[0].asnumpy()\n    prob = np.squeeze(prob)\n \n    topN = []\n    a = np.argsort(prob)[::-1]\n    for i in a[0:N]:\n        topN.append((prob[i], synsets[i]))\n    return topN\n \n# Code to download an image from the internet and run a prediction on it\ndef predict_from_url(url, N=5):\n    filename = url.split(\"/\")[-1]\n    urllib.urlretrieve(url, filename)\n    img = cv2.imread(filename)\n    if img is None:\n        print( \"Failed to download\" )\n    else:\n        return predict(filename, mod, synsets, N)\n \n \n# Code to predict on a local file\ndef predict_from_local_file(filename, N=5):\n    return predict(filename, mod, synsets, N)\n \n \nstart = time.time()\npacket_size=3000\n \n \n# Create unique image name\nuniqueid = 'mxnet_uuid_{0}_{1}.json'.format('json',strftime(\"%Y%m%d%H%M%S\",gmtime()))\n \n \nfilename = '/opt/demo/incubator-mxnet/nanotie7.png'\ntopn = []\n# Run inception prediction on image\ntry:\n     topn = predict_from_local_file(filename, N=5)\nexcept:\n     print(\"Error\")\n     errorcondition = \"true\"\n \ntry:\n     # 5 MXNET Analysis\n     top1 = str(topn[0][1])\n     top1pct = str(round(topn[0][0],3) * 100)\n \n     top2 = str(topn[1][1])\n     top2pct = str(round(topn[1][0],3) * 100)\n \n     top3 = str(topn[2][1])\n     top3pct = str(round(topn[2][0],3) * 100)\n \n     top4 = str(topn[3][1])\n     top4pct = str(round(topn[3][0],3) * 100)\n \n     top5 = str(topn[4][1])\n     top5pct = str(round(topn[4][0],3) * 100)\n \n     end = time.time()\n \n     print(\"%table top1pct\\ttop1\\top2\\ttop2pct\\ttop3pct\\ttop3\\ttop4pct\\ttop4\\ttop5pct\\ttop5\\timagefilename\\truntime\\tuuid\\n\" + top1pct + \"\\t\" + top1 + \"\\t\" +  top2pct + \"\\t\" + top2 + \"\\t\" +  top3pct + \"\\t\" + top3  + \"\\t\" + top4pct + \"\\t\" + top4 + \"\\t\" +  top5pct + \"\\t\" + top5  + \"\\t\" + filename  + \"\\t\" + str(round(end - start)) + \"\\t\" + uniqueid + \"\\n\" )\n \nexcept:\n     print(\"{\\\"message\\\": \\\"Failed to run\\\"}\")","user":"admin","dateUpdated":"2018-03-02T17:07:26+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"python"},"editorMode":"ace/mode/python"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520005851329_-285694118","id":"20180302-155051_242617183","dateCreated":"2018-03-02T15:50:51+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:1505","dateFinished":"2018-03-02T17:07:27+0000","dateStarted":"2018-03-02T17:07:26+0000","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"[17:07:26] src/nnvm/legacy_json_util.cc:209: Loading symbol saved by previous version v0.8.0. Attempting to upgrade...\n[17:07:26] src/nnvm/legacy_json_util.cc:217: Symbol successfully upgraded!\n"},{"type":"TABLE","data":"top1pct\ttop1\top2\ttop2pct\ttop3pct\ttop3\ttop4pct\ttop4\ttop5pct\ttop5\timagefilename\truntime\tuuid\n67.6\tn02883205 bow tie, bow-tie, bowtie\t11.5\tn04589890 window screen\t4.5\tn03938244 pillow\t2.8\tn04590129 window shade\t2.8\tn03485794 handkerchief, hankie, hanky, hankey\t/opt/demo/incubator-mxnet/nanotie7.png\t0.0\tmxnet_uuid_json_20180302170726.json\n"}]}},{"text":"%pyspark\n","user":"admin","dateUpdated":"2018-03-02T16:12:23+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520007143744_-1380253833","id":"20180302-161223_1480321954","dateCreated":"2018-03-02T16:12:23+0000","status":"READY","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:1622"}],"name":"mxnet","id":"2D8KQQ4YW","angularObjects":{"2CHS8UYQQ:shared_process":[],"2C8A4SZ9T_livy2:shared_process":[],"2CK8A9MEG:shared_process":[],"2C4U48MY3_spark2:shared_process":[],"2CKAY1A8Y:shared_process":[],"2CKEKWY8Z:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}